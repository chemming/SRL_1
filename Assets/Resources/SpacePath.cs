//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;
public class SpacePath: MonoBehaviourThink
{
	private List<Vector3> nodes;
	private List<Vector3> nodesUp;

	public SpacePath ()
	{

	}
	override protected void Initalize () 
	{
		nodes = new List<Vector3> ();
		nodes.Add (new Vector3 (0, 0, 1));
		nodes.Add (new Vector3 (1000, 0, 0));
		nodes.Add (new Vector3 (2000, 0, 0));
		nodes.Add (new Vector3 (3000, 0, 0));
		nodes.Add (new Vector3 (4000, 0, 0));

		nodesUp = new List<Vector3> ();
		nodesUp.Add (new Vector3 (0, 1, 0));
		nodesUp.Add (new Vector3 (0, 1, 0));
		nodesUp.Add (new Vector3 (0, 1, 0));
		nodesUp.Add (new Vector3 (0, 1, 0));
		nodesUp.Add (new Vector3 (0, 1, 0));

		//nodes.Add (new Vector3 (200, 0, 300));
		//nodes.Add (new Vector3 (300, 0, 400));



		if(SRLConfiguration.PATH_debug == 1)
		{
			for(int i = 0; i< nodes.Count-1;i++)
			{
//				Debug.Log("Drawing!");
				Debug.DrawLine (nodes[i], nodes[i+1], Color.yellow,100f);
			}
			foreach(Vector3 vec in nodes)
			{
				GameObject beacon = GameObject.Instantiate(Resources.Load<GameObject>("PathBeacon")) as GameObject;
				beacon.name = "PathBeacon";
				beacon.transform.position = vec;
				beacon.transform.parent = this.transform;
			}

		}
	}

	public Vector3 GetDestinationPoint(Vector3 spacepoint)
	{
		Vector3 nearest = Vector3.zero;
		float distance = 0;

		foreach(Vector3 node in nodes)
		{
			float d = (node - spacepoint).magnitude;
			
			if(d < distance)
			{
				distance = d;
				nearest = node;
			}
		}
		int nodeIndex = nodes.IndexOf (nearest) + 2;

		if(nodeIndex >= nodes.Count - 1)
			nodeIndex = nodes.Count - 1;

		return nodes[nodeIndex];
	}

	public Vector3 GetNearestPoint(Vector3 spacepoint, out Vector3 upVector, out Vector3 forwardVector)
	{
		Vector3[] nearest = new Vector3[3];
		float[] distance = new float[3] {1000000f, 10000000f, 10000000f};

		Vector3[] upVecs = new Vector3[3];

		foreach(Vector3 node in nodes)
		{
			float d = (node - spacepoint).magnitude;
		
			if(d < distance[0])
			{
				distance[0] = d;
				nearest[0] = node;
			}
		}

		int nodeIndex = nodes.IndexOf (nearest[0]);
		int nodeAdd1 = nodeIndex - 1;
		int nodeAdd2 = nodeIndex + 1;


		if(nodeIndex == 0)
		{

			nodeAdd1 = nodeIndex+1;
			nodeAdd2 = -1;
		}

		if(nodeIndex == nodes.Count - 1)
		{
			nodeAdd1 = nodeIndex-1;
			nodeAdd2 = -1;
		}
		if(nodeIndex < nodes.Count -1)
			forwardVector = (nodes [nodeIndex+1] - nodes [nodeIndex]).normalized ;
		else
			forwardVector = (nodes [nodeIndex] - nodes [nodeIndex-1]).normalized ;


//		Debug.Log (nodeIndex);
//		Debug.Log (nodeAdd1);

		nearest [0] = nodes [nodeIndex];
		nearest [1] = nodes [nodeAdd1];


		upVecs [0] = nodesUp [nodeIndex];
		upVecs [1] = nodesUp [nodeAdd1];

		distance [0] = (nearest [0] - spacepoint).magnitude;
		distance [1] = (nearest [1] - spacepoint).magnitude;
		if(nodeAdd2 > -1)
		{
			nearest [2] = nodes [nodeAdd2];
			distance [2] = (nearest [2] - spacepoint).magnitude;
		}

		//Select the second nearest well, based on 
		Color col = Color.green;

		Vector3 betweenMains = nearest[1] - nearest[0];
		Vector3 weightMain = Vector3.Project (spacepoint - nearest[0], betweenMains);
		Vector3 position = nearest[0] + weightMain;
		upVector = upVecs [0]/(distance [0]+0.1f) + upVecs [1]/(distance [1]+0.1f);
		upVector.Normalize ();

		if(nodeAdd2 > -1)
		{

			Vector3 betweenMinors = nearest [2] - nearest [0];
			Vector3 weightMinors = Vector3.Project (spacepoint - nearest[0], betweenMinors);
			Vector3 position2 = nearest[0] + weightMinors;

			Vector3 betweenGoals = nearest [1] - nearest [2];
			Vector3 shipBetweenMinors = Vector3.Project (spacepoint -  nearest [1] , betweenGoals);
			Vector3 nearestBetweenMinors = Vector3.Project (nearest[0] -  nearest [1] , betweenGoals);
			//Vector3 shipBetweenMinors = Vector3.Project (spacepoint -  nearest [1] , betweenGoals);
			//Vector3 nearestBetweenMinors = Vector3.Project (nearest[0] -  nearest [1] , betweenGoals);


				
			if ((weightMinors.normalized + betweenMinors.normalized).magnitude  < 0.01f)
			{
				position2 = nearest [0];

			}

			if ((weightMain.normalized + betweenMains.normalized).magnitude < 0.01f)
			{
				position = position2;
			}


			float fadeMag = nearestBetweenMinors.magnitude - shipBetweenMinors.magnitude;
			fadeMag = fadeMag/15f;
			if( fadeMag < 0)
				fadeMag = 0;
			if( fadeMag > 1)
				fadeMag = 1;

			position = position2 * (1-fadeMag) + position*fadeMag ;

			if(SRLConfiguration.PATH_debug == 1)
			{
				Debug.DrawLine (nearest [1] + Vector3.one*0.2f
				                ,nearest [1] + betweenGoals + Vector3.one*0.2f
				                , Color.blue,0.01f);
				Debug.DrawLine (nearest [1] + Vector3.one*0.4f
				                ,  nearest [1] + shipBetweenMinors  + Vector3.one*0.4f
				                , Color.white,0.01f);
				Debug.DrawLine (nearest [1]  + Vector3.one*0.6f
				                ,  nearest [1] + nearestBetweenMinors  + Vector3.one*0.6f
				                , Color.red,0.01f);
			}
		}
		else
		{

			if ((weightMain.normalized + betweenMains.normalized).magnitude < 0.01f)
				position = nearest [0];
		}
		if(SRLConfiguration.PATH_debug == 1)
		{
			Debug.DrawLine (nearest[0], position, Color.red);
			Debug.DrawLine (position + new Vector3(0.1f,0.1f,0.1f), position, col,100f);
		}
			//Debug.DrawLine (nearest[0], position, Color.magenta);

		return position;

		//Gets the nearest point on the path.

	}

	public Vector3 GetLastPoint()
	{
		return nodes [nodes.Count - 1];
	}

	override protected void ThinkFast ()
	{


	}

	override protected void Think ()
	{
		
		
	}
	

}

